// Package main for entrypoint reset program.
package main

import (
	"bytes"
	"context"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall" //nolint needs to call sigterm for asinc program termination.

	"github.com/samborkent/uuidv7"
	"golang.org/x/sync/errgroup"
)

var (
	fileCh = make(chan string, 100)
)

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Println("Starts resetting")

	// Setup signal handler
	go func() {
		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt, syscall.SIGTERM)
		<-c
		cancel()
	}()

	// Use errgroup to manage file processing goroutine
	eg, egCtx := errgroup.WithContext(ctx)

	// Goroutine to walk files and send them to channel
	eg.Go(func() error {
		defer close(fileCh)

		dir, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("getwd: %w", err)
		}

		basePath := filepath.Dir(filepath.Dir(dir))

		err = filepath.Walk(basePath, func(path string, info fs.FileInfo, err error) error {
			if err != nil {
				log.Printf("Error accessing path %s: %v\n", path, err)
				return err
			}

			if !strings.HasSuffix(info.Name(), ".go") {
				return nil
			}

			if strings.Contains(info.Name(), ".gen.") {
				return nil
			}

			select {
			case fileCh <- path:
			case <-egCtx.Done():
				return egCtx.Err()
			}

			return nil
		})
		if err != nil {
			return fmt.Errorf("filepath.Walk: %w", err)
		}

		return nil
	})

	// Process files
	for path := range fileCh {
		select {
		case <-egCtx.Done():
			return
		default:
			if err := doGReset(egCtx, path); err != nil {
				log.Printf("Error processing %s: %v\n", path, err)
			}
		}
	}

	// Wait for file walking goroutine to complete
	if err := eg.Wait(); err != nil {
		cancel()
		// nolint:gocritic // log fatal on main error with no deferring cancel.
		log.Fatalf("Error: %v\n", err)
	}
}

func doGReset(_ context.Context, path string) error {
	fset := token.NewFileSet()

	f, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("parse %s: %w", path, err)
	}

	structs := make([]*ast.StructType, 0, 2)
	names := make([]string, 0, 2)

	for _, decl := range f.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok {
			for _, spec := range genDecl.Specs {
				if typeSpec, ok := spec.(*ast.TypeSpec); ok {
					if structWithReset, isStruct := typeSpec.Type.(*ast.StructType); isStruct {
						if genDecl.Doc != nil {
							// genDecl.Doc contains the comment group above the struct
							for _, comment := range genDecl.Doc.List {
								if strings.Contains(comment.Text, "generate:reset") {
									structs = append(structs, structWithReset)
									names = append(names, typeSpec.Name.Name)
								}
							}
						}
					}
				}
			}
		}
	}

	if len(structs) > 0 {
		buf := generateResetMethod(structs, names, f.Name.Name)

		err := writeGenerated(buf, path)
		if err != nil {
			return fmt.Errorf("write generated for %s: %w", path, err)
		}

		log.Printf("setup Reset() for structs in %s\n", path)
	}

	return nil
}

func generateResetMethod(structs []*ast.StructType, names []string, pkgName string) *bytes.Buffer {
	buf := bytes.NewBufferString(`// Code generated by reset; DO NOT EDIT.
	// This file was generated by reset util.
	package ` + pkgName + "\n")

	for i, s := range structs {
		buf.WriteString(`
// Reset resets all fields of struct to base. 
func (rs *` + names[i] + `) Reset() {
	if rs == nil {
        return
		}` + "\n")

		for _, field := range s.Fields.List {
			fieldName := ""
			fieldResetter := ""

			if len(field.Names) > 0 {
				fieldName = field.Names[0].Name

				switch t := field.Type.(type) {
				case *ast.Ident:
					fieldResetter = "rs." + fieldName + "= " + primitiveStrVal(t) + "\n"
				case *ast.ArrayType:
					fieldResetter = "rs." + fieldName + "= rs." + fieldName + "[:0]" + "\n"
				case *ast.MapType:
					fieldResetter = "clear(rs." + fieldName + ")" + "\n"
				case *ast.StarExpr: // Pointer types
					if ident, ok := t.X.(*ast.Ident); ok {
						fieldResetter = "if rs." + fieldName + `!= nil {\n*rs.` + fieldName + " = " + primitiveStrVal(ident) + `\n}\n`
					}
				case *ast.StructType:
					fieldResetter = `if resetter, ok := rs.` + fieldName +
						`.(interface{ Reset() }); ok && rs.` + fieldName +
						` != nil {\nresetter.Reset()\n}\n`
				}

				buf.WriteString("\t" + fieldResetter)
			} else {
				// Handle embedded fields (e.g., `*MyEmbeddedStruct`)
				if starExpr, ok := field.Type.(*ast.StarExpr); ok {
					if ident, ok := starExpr.X.(*ast.Ident); ok {
						fieldName = ident.Name // Embedded field name
						fieldResetter = "rs." + fieldName + "= " + primitiveStrVal(ident) + "\n"
						buf.WriteString("\t" + fieldResetter)
					}
				} else if ident, ok := field.Type.(*ast.Ident); ok {
					fieldName = ident.Name // Embedded field name (without pointer)
					fieldResetter = "rs." + fieldName + "= " + primitiveStrVal(ident) + "\n"
					buf.WriteString("\t" + fieldResetter)
				}
			}
		}

		buf.WriteString("}\n\n")
	}

	return buf
}

func primitiveStrVal(t *ast.Ident) string {
	if t.Name == "string" {
		return `""`
	}

	if t.Name == "UUIDv7" || t.Name == "UserID" {
		return `"` + uuidv7.New().String() + `"`
	}

	if strings.Contains(t.Name, "float") || strings.Contains(t.Name, "int") {
		return "0"
	}

	if t.Name == "bool" {
		return "false"
	}

	return ""
}

func writeGenerated(buf *bytes.Buffer, path string) error {
	pathGen := path[:len(path)-2] + "gen.go"

	bufFmt, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("writeGenerated: %w", err)
	}

	return fmt.Errorf("writeGenerated: %w", os.WriteFile(pathGen, bufFmt, 0600))
}
