package main

import (
	"bytes"
	"context"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"

	"github.com/samborkent/uuidv7"
)

var (
	fileCh = make(chan string)
)

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	log.Println("Starts resetting")

	go func() {
		c := make(chan os.Signal, 1) // we need to reserve to buffer size 1, so the notifier are not blocked
		signal.Notify(c, os.Interrupt, syscall.SIGTERM)

		<-c
		cancel()
	}()

	go func() {
		dir, err := os.Getwd()
		if err != nil {
			log.Fatal(err)
		}
		basePath := filepath.Dir(filepath.Dir(dir))
		err = filepath.Walk(basePath, func(path string, info fs.FileInfo, err error) error {
			if err != nil {
				// Handle errors that occurred during the walk
				fmt.Printf("Error accessing path %s: %v\n", path, err)
				return err // Continue walking or return a specific error
			}
			if !strings.HasSuffix(info.Name(), ".go") {
				return nil
			}
			if strings.Contains(info.Name(), ".gen.") {
				return nil
			}
			fileCh <- path
			return nil
		})
		if err != nil {
			fmt.Printf("Error during file system walk: %v\n", err)
		}
		close(fileCh)
	}()

	for path := range fileCh {
		select {
		case <-ctx.Done():
			return
		default:
			doGReset(ctx, path)
		}

	}
}

func doGReset(_ context.Context, path string) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	structs := make([]*ast.StructType, 0, 2)
	names := make([]string, 0, 2)
	for _, decl := range f.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok {
			for _, spec := range genDecl.Specs {
				if typeSpec, ok := spec.(*ast.TypeSpec); ok {
					if structWithReset, isStruct := typeSpec.Type.(*ast.StructType); isStruct {

						if genDecl.Doc != nil {
							// genDecl.Doc contains the comment group above the struct
							for _, comment := range genDecl.Doc.List {
								if strings.Contains(comment.Text, "generate:reset") {
									structs = append(structs, structWithReset)
									names = append(names, typeSpec.Name.Name)

								}
							}
						}
					}
				}
			}

		}
	}
	if len(structs) > 0 {
		buf := generateResetMethod(structs, names, f.Name.Name)
		err := writeGenereted(buf, path)
		if err != nil {
			log.Fatalf("unable to write file for %s", path)
		}
		log.Printf("setup Reset() for structs in %s\n", path)
	}
}

func generateResetMethod(structs []*ast.StructType, names []string, pkgName string) *bytes.Buffer {
	buf := bytes.NewBufferString(`// Code generated by reset; DO NOT EDIT.
	// This file was generated by reset util.
	package ` + pkgName + "\n")

	for i, s := range structs {
		buf.WriteString(`
// Reset resets all fields of struct to base. 
func (rs *` + names[i] + `) Reset() {
	if rs == nil {
        return
		}` + "\n")
		for _, field := range s.Fields.List {
			fieldName := ""
			fieldResetter := ""
			if len(field.Names) > 0 {
				fieldName = field.Names[0].Name

				switch t := field.Type.(type) {
				case *ast.Ident:
					fieldResetter = "rs." + fieldName + "= " + primitiveStrVal(t) + "\n"
				case *ast.ArrayType:
					fieldResetter = "rs." + fieldName + "= rs." + fieldName + "[:0]" + "\n"
				case *ast.MapType:
					fieldResetter = "clear(rs." + fieldName + ")" + "\n"
				case *ast.StarExpr: // Pointer types
					if ident, ok := t.X.(*ast.Ident); ok {
						fieldResetter = "if rs." + fieldName + `!= nil {\n*rs.` + fieldName + " = " + primitiveStrVal(ident) + `\n}\n`
					}
				case *ast.StructType:
					fieldResetter = `if resetter, ok := rs.` + fieldName +
						`.(interface{ Reset() }); ok && rs.` + fieldName +
						` != nil {\nresetter.Reset()\n}\n`
				}
				buf.WriteString("\t" + fieldResetter)
			} else {
				// Handle embedded fields (e.g., `*MyEmbeddedStruct`)
				if starExpr, ok := field.Type.(*ast.StarExpr); ok {
					if ident, ok := starExpr.X.(*ast.Ident); ok {
						fieldName = ident.Name // Embedded field name
						fieldResetter = "rs." + fieldName + "= " + primitiveStrVal(ident) + "\n"
						buf.WriteString("\t" + fieldResetter)
					}
				} else if ident, ok := field.Type.(*ast.Ident); ok {
					fieldName = ident.Name // Embedded field name (without pointer)
					fieldResetter = "rs." + fieldName + "= " + primitiveStrVal(ident) + "\n"
					buf.WriteString("\t" + fieldResetter)
				}
			}

		}
		buf.WriteString("}\n\n")
	}
	return buf
}

func primitiveStrVal(t *ast.Ident) string {
	if t.Name == "string" {
		return `""`
	}
	if t.Name == "UUIDv7" || t.Name == "UserID" {
		return `"` + uuidv7.New().String() + `"`
	}
	if strings.Contains(t.Name, "float") || strings.Contains(t.Name, "int") {
		return "0"
	}
	if t.Name == "bool" {
		return "false"
	}
	return ""
}

func writeGenereted(buf *bytes.Buffer, path string) error {
	pathGen := path[:len(path)-2] + "gen.go"
	fmt.Println(buf.String())
	bufFmt, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return os.WriteFile(pathGen, bufFmt, 0664)
}
